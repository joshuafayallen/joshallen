{
  "hash": "c7b9c4c2cc505e27b42877aa812fa034",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tidyverse to SQL\"\nformat: html\n---\n\n\n\nSince I am going on the non-academic job market it is high time I learned SQL. I have tried lots of amazing resources but find it hard for me to navigate between notes and various and learning SQL since they are just familiar enough to trip me up and lots of them send you off to various editors. This blog post will serve as my notes and hopefully as a resource for not myself. The general idea is I am just going to work through R4DS and the various `dplyr` verbs. Then move onto some more advanced SQL stuff like window functions and what not. \n\n## Setup\n\nFor the majority of this `palmerpenguins` dataset not because you really need to use `SQL` for a dataset this small but copying over the `nyc-taxi` dataset is incredibly annoying for blogging purposes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DBI)\nlibrary(arrow)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'arrow'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:utils':\n\n    timestamp\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(dbplyr)\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ lubridate::duration() masks arrow::duration()\n✖ dplyr::filter()       masks stats::filter()\n✖ dplyr::ident()        masks dbplyr::ident()\n✖ dplyr::lag()          masks stats::lag()\n✖ dplyr::sql()          masks dbplyr::sql()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\npengs = palmerpenguins::penguins\n\ncon =  src_memdb()\n\npengs = copy_to(con, pengs,\n       overwrite = TRUE)\n```\n:::\n\n\n\nWe are going to go back and forth using `dbplyr` and `SQL` to query the dataset. What impressed me throughout this process was how seamless `dbplyr` works with dplyr verbs work. With the exception of some string functions it can work as a drop in replacement for SQL. What really helped throughout this process was writing out my queries and using `show_query`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npengs |>\n    select(species) |>\n    show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `species`\nFROM `pengs`\n```\n\n\n:::\n:::\n\n\n\nWhich will give us a SQL query. Obviously this is a pretty simple query but as we get more and more complex this is going to be helpful.  For the most part `show_query` outputs the right query but can be a little bit difficult to debug because of the limitations of showing things in the R console. \n\n# Dplyr\n\n## Select \n\nOne convention in SQL which I don't really get but is a thing is that functions are defined using all caps. Luckily for us the SQL and dplyr versions are pretty much the same one is just shouty. If we wanted all the columns like we may when we are importing the dataset for the first time we are just going to do `SELECT * FROM taxis`. There is really not like a perfect equivalent in R except for maybe head. But even then it is not a perfect one to one.\n\n\n:::panel-tabsets\n\n## R \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(pengs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [6 x 8]\n# Database: sqlite 3.46.0 [:memory:]\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# ℹ 2 more variables: sex <chr>, year <int>\n```\n\n\n:::\n:::\n\n\n\n## SQL \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT * FROM pengs\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 8]\n# Database: sqlite 3.46.0 [:memory:]\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ more rows\n# ℹ 2 more variables: sex <chr>, year <int>\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\nFor one or multiple variables we are going to use a very similar syntax but were SQL and R differ is where we put the object we are querying from meaning in R we use the pipe to use data as the first argument of `select` but in SQL we put the object name behind the columns we are selecting like this \n\n:::panel-tabset\n\n## R \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npengs |>\n    select(body_mass_g, flipper_length_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 2]\n# Database: sqlite 3.46.0 [:memory:]\n   body_mass_g flipper_length_mm\n         <int>             <int>\n 1        3750               181\n 2        3800               186\n 3        3250               195\n 4          NA                NA\n 5        3450               193\n 6        3650               190\n 7        3625               181\n 8        4675               195\n 9        3475               193\n10        4250               190\n# ℹ more rows\n```\n\n\n:::\n:::\n\n\n\n## SQL\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT body_mass_g, flipper_length_mm FROM pengs\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 2]\n# Database: sqlite 3.46.0 [:memory:]\n   body_mass_g flipper_length_mm\n         <int>             <int>\n 1        3750               181\n 2        3800               186\n 3        3250               195\n 4          NA                NA\n 5        3450               193\n 6        3650               190\n 7        3625               181\n 8        4675               195\n 9        3475               193\n10        4250               190\n# ℹ more rows\n```\n\n\n:::\n:::\n\n\n\n:::\n\nSo what if we want to keep all but one column we would do this in R \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npengs |>\n    select(-species) |>\n    head(n =2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [2 x 7]\n# Database: sqlite 3.46.0 [:memory:]\n  island  bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex    year\n  <chr>            <dbl>         <dbl>             <int>       <int> <chr> <int>\n1 Torger…           39.1          18.7               181        3750 male   2007\n2 Torger…           39.5          17.4               186        3800 fema…  2007\n```\n\n\n:::\n:::\n\n\n\nUnfortunately that is really not like a thing in some flavors of `SQL` other flavors of SQL you can use `except` but as the results from show query suggests we actually need to feed it all the columns we want. This would be the same thing if we wanted to use `starts_with`. \n\n\n\n## Filter\n\nThe first major difference syntactically between dplyr and SQL is with filter statements aka `WHERE` statements in SQL. So let’s say we want only penguins that are Adelie penguins. \n\n:::panel-tabset\n\n## R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npengs |>\n    filter(species == 'Adelie')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 8]\n# Database: sqlite 3.46.0 [:memory:]\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ more rows\n# ℹ 2 more variables: sex <chr>, year <int>\n```\n\n\n:::\n:::\n\n\n\nBecomes. \n\n## SQL\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con,sql( \"\n    SELECT * from pengs\n    WHERE species = 'Adelie'\n\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 8]\n# Database: sqlite 3.46.0 [:memory:]\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ more rows\n# ℹ 2 more variables: sex <chr>, year <int>\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::aside\n\nSome flavors of SQL make you end lines with ';'\n:::\n\nAs `dplyr` users will notice the way we specified the equality position uses the `=` instead of `==`. This is going to come up a lot. The same thing goes for negation operations. \n\n:::panel-tabset\n\n## R \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npengs |>\n    filter(species != 'Adelie')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 8]\n# Database: sqlite 3.46.0 [:memory:]\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>           <dbl>         <dbl>             <int>       <int>\n 1 Gentoo  Biscoe           46.1          13.2               211        4500\n 2 Gentoo  Biscoe           50            16.3               230        5700\n 3 Gentoo  Biscoe           48.7          14.1               210        4450\n 4 Gentoo  Biscoe           50            15.2               218        5700\n 5 Gentoo  Biscoe           47.6          14.5               215        5400\n 6 Gentoo  Biscoe           46.5          13.5               210        4550\n 7 Gentoo  Biscoe           45.4          14.6               211        4800\n 8 Gentoo  Biscoe           46.7          15.3               219        5200\n 9 Gentoo  Biscoe           43.3          13.4               209        4400\n10 Gentoo  Biscoe           46.8          15.4               215        5150\n# ℹ more rows\n# ℹ 2 more variables: sex <chr>, year <int>\n```\n\n\n:::\n:::\n\n\n\n## SQL \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT * from pengs \n             WHERE NOT species = 'Adelie'\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 8]\n# Database: sqlite 3.46.0 [:memory:]\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>           <dbl>         <dbl>             <int>       <int>\n 1 Gentoo  Biscoe           46.1          13.2               211        4500\n 2 Gentoo  Biscoe           50            16.3               230        5700\n 3 Gentoo  Biscoe           48.7          14.1               210        4450\n 4 Gentoo  Biscoe           50            15.2               218        5700\n 5 Gentoo  Biscoe           47.6          14.5               215        5400\n 6 Gentoo  Biscoe           46.5          13.5               210        4550\n 7 Gentoo  Biscoe           45.4          14.6               211        4800\n 8 Gentoo  Biscoe           46.7          15.3               219        5200\n 9 Gentoo  Biscoe           43.3          13.4               209        4400\n10 Gentoo  Biscoe           46.8          15.4               215        5150\n# ℹ more rows\n# ℹ 2 more variables: sex <chr>, year <int>\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\nIf we want multiple conditions in our where statements instead of `|` or `&/,` we actually just use the words `or` and `and`\n\n:::panel-tabset\n\n## R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npengs |>\n    filter(species == 'Chinstrap' | species == 'Adelie')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 8]\n# Database: sqlite 3.46.0 [:memory:]\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ more rows\n# ℹ 2 more variables: sex <chr>, year <int>\n```\n\n\n:::\n:::\n\n\n\nbecomes \n\n## SQL\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT * from pengs \n            WHERE species = 'Adelie' OR species = 'Chinstrap'\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 8]\n# Database: sqlite 3.46.0 [:memory:]\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ more rows\n# ℹ 2 more variables: sex <chr>, year <int>\n```\n\n\n:::\n:::\n\n\n\n:::\n\nYou could easily sub in `AND` but that feels a bit excessive to continue this process for each possible combination. One thing that I do all the time is use sets to subset my data. \n\n:::panel-tabset\n\n## R \n\n\n::: {.cell}\n\n```{.r .cell-code}\npengs |>\n    filter(species %in% c('Chinstrap', \"Gentoo\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 8]\n# Database: sqlite 3.46.0 [:memory:]\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>           <dbl>         <dbl>             <int>       <int>\n 1 Gentoo  Biscoe           46.1          13.2               211        4500\n 2 Gentoo  Biscoe           50            16.3               230        5700\n 3 Gentoo  Biscoe           48.7          14.1               210        4450\n 4 Gentoo  Biscoe           50            15.2               218        5700\n 5 Gentoo  Biscoe           47.6          14.5               215        5400\n 6 Gentoo  Biscoe           46.5          13.5               210        4550\n 7 Gentoo  Biscoe           45.4          14.6               211        4800\n 8 Gentoo  Biscoe           46.7          15.3               219        5200\n 9 Gentoo  Biscoe           43.3          13.4               209        4400\n10 Gentoo  Biscoe           46.8          15.4               215        5150\n# ℹ more rows\n# ℹ 2 more variables: sex <chr>, year <int>\n```\n\n\n:::\n:::\n\n\n\nBecomes \n\n## SQL\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT * from pengs\n            WHERE species IN ('Chinstrap', 'Gentoo')\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 8]\n# Database: sqlite 3.46.0 [:memory:]\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>           <dbl>         <dbl>             <int>       <int>\n 1 Gentoo  Biscoe           46.1          13.2               211        4500\n 2 Gentoo  Biscoe           50            16.3               230        5700\n 3 Gentoo  Biscoe           48.7          14.1               210        4450\n 4 Gentoo  Biscoe           50            15.2               218        5700\n 5 Gentoo  Biscoe           47.6          14.5               215        5400\n 6 Gentoo  Biscoe           46.5          13.5               210        4550\n 7 Gentoo  Biscoe           45.4          14.6               211        4800\n 8 Gentoo  Biscoe           46.7          15.3               219        5200\n 9 Gentoo  Biscoe           43.3          13.4               209        4400\n10 Gentoo  Biscoe           46.8          15.4               215        5150\n# ℹ more rows\n# ℹ 2 more variables: sex <chr>, year <int>\n```\n\n\n:::\n:::\n\n\n\n:::\n\nin this case we define a set in a similar way. If we wanted to negate this statement all we would do is \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT * from pengs\n            WHERE NOT species IN ('Chinstrap', 'Gentoo')\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 8]\n# Database: sqlite 3.46.0 [:memory:]\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ more rows\n# ℹ 2 more variables: sex <chr>, year <int>\n```\n\n\n:::\n:::\n\n\n\nLets say we want to find penguins that are less than the average body mass in R this is fairly straightforward\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npengs |>\n    filter(body_mass_g < mean(body_mass_g, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 8]\n# Database: sqlite 3.46.0 [:memory:]\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           36.7          19.3               193        3450\n 5 Adelie  Torgersen           39.3          20.6               190        3650\n 6 Adelie  Torgersen           38.9          17.8               181        3625\n 7 Adelie  Torgersen           34.1          18.1               193        3475\n 8 Adelie  Torgersen           37.8          17.1               186        3300\n 9 Adelie  Torgersen           37.8          17.3               180        3700\n10 Adelie  Torgersen           41.1          17.6               182        3200\n# ℹ more rows\n# ℹ 2 more variables: sex <chr>, year <int>\n```\n\n\n:::\n:::\n\n\n\nHowever when we do this in some flavor of `SQL` it is not as straightforward. These are aggregation functions that `where` can't handle because thats not its job.  So if we did \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, \"SELECT * from pengs WHERE body_mass_g < AVG(body_mass_g)\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `db_query_fields.DBIConnection()`:\n! Can't query fields.\nℹ Using SQL: SELECT * FROM `SELECT * from pengs WHERE body_mass_g <\n  AVG(body_mass_g)` AS `q01` WHERE (0 = 1)\nCaused by error:\n! no such table: SELECT * from pengs WHERE body_mass_g < AVG(body_mass_g)\n```\n\n\n:::\n:::\n\n\n\nWe get an error. If we wanted to use aggregation functions we have to change how we do this \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npengs |>\n    filter(body_mass_g < mean(body_mass_g, na.rm = TRUE)) |>\n    show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT\n  `species`,\n  `island`,\n  `bill_length_mm`,\n  `bill_depth_mm`,\n  `flipper_length_mm`,\n  `body_mass_g`,\n  `sex`,\n  `year`\nFROM (\n  SELECT `pengs`.*, AVG(`body_mass_g`) OVER () AS `col01`\n  FROM `pengs`\n) AS `q01`\nWHERE (`body_mass_g` < `col01`)\n```\n\n\n:::\n:::\n\n\n\nWhat is this `OVER` thing? `OVER` in SQL is a window function. There is a more technical way to explain this but heuristically when we pass `AVG` to `WHERE` we are effectively doing this. So there is not really anything to compare it too.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npengs |>\n    summarise(mean(body_mass_g, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [1 x 1]\n# Database: sqlite 3.46.0 [:memory:]\n  `mean(body_mass_g, na.rm = TRUE)`\n                              <dbl>\n1                             4202.\n```\n\n\n:::\n:::\n\n\n\nIf we wanted to filter penguins that are less than the average body mass we have to prevent this aggregation process by creating a column and then creating a less than statement like this \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT * FROM(\n              SELECT pengs .*, AVG(body_mass_g) OVER () AS avg\n               FROM pengs)\n              WHERE (body_mass_g < avg)\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 9]\n# Database: sqlite 3.46.0 [:memory:]\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           36.7          19.3               193        3450\n 5 Adelie  Torgersen           39.3          20.6               190        3650\n 6 Adelie  Torgersen           38.9          17.8               181        3625\n 7 Adelie  Torgersen           34.1          18.1               193        3475\n 8 Adelie  Torgersen           37.8          17.1               186        3300\n 9 Adelie  Torgersen           37.8          17.3               180        3700\n10 Adelie  Torgersen           41.1          17.6               182        3200\n# ℹ more rows\n# ℹ 3 more variables: sex <chr>, year <int>, avg <dbl>\n```\n\n\n:::\n:::\n\n\n\nIt is a little clunky but the tl;dr is that we basically have two `FROM` statements so if we wanted all penguins between the minimum and the average we could do \n\n:::panel-tabset\n\n## R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npalmerpenguins::penguins |>\n    filter(between(body_mass_g, left = min(body_mass_g, na.rm = TRUE), right = mean(body_mass_g, na.rm = TRUE)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 193 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           36.7          19.3               193        3450\n 5 Adelie  Torgersen           39.3          20.6               190        3650\n 6 Adelie  Torgersen           38.9          17.8               181        3625\n 7 Adelie  Torgersen           34.1          18.1               193        3475\n 8 Adelie  Torgersen           37.8          17.1               186        3300\n 9 Adelie  Torgersen           37.8          17.3               180        3700\n10 Adelie  Torgersen           41.1          17.6               182        3200\n# ℹ 183 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\n\n## SQL\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT * FROM(\n             SELECT pengs .*, AVG(body_mass_g) OVER() AS avg, MIN(body_mass_g) OVER() AS min\n            FROM pengs)\n            WHERE body_mass_g BETWEEN min AND avg\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 10]\n# Database: sqlite 3.46.0 [:memory:]\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           36.7          19.3               193        3450\n 5 Adelie  Torgersen           39.3          20.6               190        3650\n 6 Adelie  Torgersen           38.9          17.8               181        3625\n 7 Adelie  Torgersen           34.1          18.1               193        3475\n 8 Adelie  Torgersen           37.8          17.1               186        3300\n 9 Adelie  Torgersen           37.8          17.3               180        3700\n10 Adelie  Torgersen           41.1          17.6               182        3200\n# ℹ more rows\n# ℹ 4 more variables: sex <chr>, year <int>, avg <dbl>, min <int>\n```\n\n\n:::\n:::\n\n\n\n:::\n\nIf you notice in all our examples, we have lots and lots of missing values. This is one of the most common tasks in like any data science task. Let’s say that we can safely ignore the missing valus. In R we have a lot of options whether we are using filter or `drop_na` from tidyr. However, in SQL missing values are usually represented by `NULL`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECt * FROM pengs \n                WHERE NOT sex IS NULL\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 8]\n# Database: sqlite 3.46.0 [:memory:]\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           36.7          19.3               193        3450\n 5 Adelie  Torgersen           39.3          20.6               190        3650\n 6 Adelie  Torgersen           38.9          17.8               181        3625\n 7 Adelie  Torgersen           39.2          19.6               195        4675\n 8 Adelie  Torgersen           41.1          17.6               182        3200\n 9 Adelie  Torgersen           38.6          21.2               191        3800\n10 Adelie  Torgersen           34.6          21.1               198        4400\n# ℹ more rows\n# ℹ 2 more variables: sex <chr>, year <int>\n```\n\n\n:::\n:::\n\n\n\n## Rename\n\nThe `AS` function is kind the work horse for the next few sections. The naming convention differs a little bit so instead of `new_name = old_name` we do `SELECT old_name as new_name`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT species AS kinds_of_penguins\n          FROM pengs\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 1]\n# Database: sqlite 3.46.0 [:memory:]\n   kinds_of_penguins\n   <chr>            \n 1 Adelie           \n 2 Adelie           \n 3 Adelie           \n 4 Adelie           \n 5 Adelie           \n 6 Adelie           \n 7 Adelie           \n 8 Adelie           \n 9 Adelie           \n10 Adelie           \n# ℹ more rows\n```\n\n\n:::\n:::\n\n\n\n## Mutate \n\nAs lots of things go we need to be able to create our own variables. So to do this in R we do this \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npengs |>\n    mutate(sqr_body_mass = body_mass_g^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 9]\n# Database: sqlite 3.46.0 [:memory:]\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ more rows\n# ℹ 3 more variables: sex <chr>, year <int>, sqr_body_mass <dbl>\n```\n\n\n:::\n:::\n\n\n\nIn SQL to get the equivalent statement we use `SELECT transformation AS new_var_name`  when we need to do things that are not in the dataset. So we basically need to define the column before we do anything.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT pengs .*, POWER(body_mass_g,2) AS sqr_body_mass\n            FROM pengs\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 9]\n# Database: sqlite 3.46.0 [:memory:]\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ more rows\n# ℹ 3 more variables: sex <chr>, year <int>, sqr_body_mass <dbl>\n```\n\n\n:::\n:::\n\n\n\nSo if we needed wanted to make a ratio of bill depth to bill length we would do \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT pengs .*, bill_depth_mm/bill_length_mm AS ratio \n            FROM pengs\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 9]\n# Database: sqlite 3.46.0 [:memory:]\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ more rows\n# ℹ 3 more variables: sex <chr>, year <int>, ratio <dbl>\n```\n\n\n:::\n:::\n\n\n\nA very important thing we do all the time is generate indicator variables for treatment status gender etc. Oddly enough if we peep the output of `show query` we see a familiar face! \n\n## R \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npengs |>\n    mutate(male = ifelse(sex == 'Male', 1, 0)) |>\n    show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT\n  `pengs`.*,\n  CASE WHEN (`sex` = 'Male') THEN 1.0 WHEN NOT (`sex` = 'Male') THEN 0.0 END AS `male`\nFROM `pengs`\n```\n\n\n:::\n:::\n\n\n\n\nSo to make an indicator variable we would just do \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT pengs.*, CASE WHEN (sex = 'male') THEN 1.0 WHEN not (sex = 'male') THEN 0.0 END AS male\n             FROM pengs\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 9]\n# Database: sqlite 3.46.0 [:memory:]\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ more rows\n# ℹ 3 more variables: sex <chr>, year <int>, male <dbl>\n```\n\n\n:::\n:::\n\n\n\nLet’s combine our window functions with our friend case_when\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT * FROM(SELECT pengs .*,\n           AVG(body_mass_g) AS avg, MIN(body_mass_g) AS min, MAX(body_mass_g) AS max,\n            CASE WHEN (body_mass_g = min) THEN 'This penguins is small' WHEN (body_mass_g = avg) THEN 'This is an average sized penguin' WHEN (body_mass_g = max) THEN 'this is a really big penguin' END AS note \n            FROM pengs)\"))\n```\n:::\n\n\n\nI will spare you the long output of the error message. But needless to say this was wrong. If we translate what I was trying to do into dplyr we get this \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npengs |>\n    mutate(note = case_when(\n            body_mass_g == min(body_mass_g) ~ 'This is a small peng',\n            body_mass_g == mean(body_mass_g) ~ 'Average sized peng',\n            body_mass_g == max(body_mass_g) ~ 'Big sized peng',\n             .default = 'Penguin is some size')) |>\n        show_query()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Missing values are always removed in SQL aggregation functions.\nUse `na.rm = TRUE` to silence this warning\nThis warning is displayed once every 8 hours.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT\n  `pengs`.*,\n  CASE\nWHEN (`body_mass_g` = MIN(`body_mass_g`) OVER `win1`) THEN 'This is a small peng'\nWHEN (`body_mass_g` = AVG(`body_mass_g`) OVER `win1`) THEN 'Average sized peng'\nWHEN (`body_mass_g` = MAX(`body_mass_g`) OVER `win1`) THEN 'Big sized peng'\nELSE 'Penguin is some size'\nEND AS `note`\nFROM `pengs`\nWINDOW `win1` AS ()\n```\n\n\n:::\n:::\n\n\n\nSo it looks like we need to change the window function \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncheck = tbl(con, sql(\"SELECT pengs .*,\n              CASE\n            WHEN (body_mass_g >= MIN(body_mass_g) OVER win1) THEN 'this is a small penguin'\n            WHEN (body_mass_g = AVG(body_mass_g) OVER win1) THEN 'this is an average sized penguin'\n            WHEN (body_mass_g = MAX(body_mass_g) OVER win1) THEN 'this is a big penguin'\n            ELSE 'This penguin is not big, small or average'\n            END AS note\n            FROM pengs \n            WINDOW win1 AS ()\")) |>\n                collect()\n```\n:::\n\n\n\nLets look at this a little closer to make sure this worked. We would probably want to make this a little more robust. So lets go ahead and define a range. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT pengs .*,\n              CASE\n            WHEN (body_mass_g >= MIN(body_mass_g) OR body_mass_g < AVG(body_mass_g)  OVER win1) THEN 'this is a small penguin'\n            WHEN (body_mass_g >= AVG(body_mass_g) OR body_mass_g < MAX(body_mass_G) OVER win1) THEN 'this is an average sized penguin'\n            WHEN (body_mass_g >= MAX(body_mass_g) OVER win1) THEN 'this is a big penguin'\n            ELSE 'This penguin is not big, small or average'\n            END AS note\n            FROM pengs \n            WINDOW win1 AS ()\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [1 x 9]\n# Database: sqlite 3.46.0 [:memory:]\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <chr>     <chr>           <dbl>         <dbl>             <int>       <int>\n1 Chinstrap Dream            46.9          16.6               192        2700\n# ℹ 3 more variables: sex <chr>, year <int>, note <chr>\n```\n\n\n:::\n:::\n\n\n\n\n\n## Group by and summarize \n\nAs established earlier we can use SQL to summarize like this. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql('SELECT AVG(bill_depth_mm) AS avg\n           FROM pengs'))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [1 x 1]\n# Database: sqlite 3.46.0 [:memory:]\n    avg\n  <dbl>\n1  17.2\n```\n\n\n:::\n:::\n\n\n\nBut the actual practical utility is somewhat limited. Often we want group specific differences. Oddly enough I expected this to be a window function thing, but we actually delay computing of the mean by different groups to the end. I guess this makes sense if we are dealing with big data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT species, AVG(body_mass_g) AS avg_body_mass\n            FROM pengs\n            GROUP BY species\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [3 x 2]\n# Database: sqlite 3.46.0 [:memory:]\n  species   avg_body_mass\n  <chr>             <dbl>\n1 Adelie            3701.\n2 Chinstrap         3733.\n3 Gentoo            5076.\n```\n\n\n:::\n:::\n\n\n\nSo if we wanted to count of the species we would do something along this line \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT species, COUNT(species) AS total\n            FROM pengs \n            GROUP BY species\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [3 x 2]\n# Database: sqlite 3.46.0 [:memory:]\n  species   total\n  <chr>     <int>\n1 Adelie      152\n2 Chinstrap    68\n3 Gentoo      124\n```\n\n\n:::\n:::\n\n\n\nFor multiple grouping variables we would define the grouping variables the same way as we would in `dplyr`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT species, sex, COUNT(species) AS total\n            FROM pengs \n            GROUP BY species, sex\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [8 x 3]\n# Database: sqlite 3.46.0 [:memory:]\n  species   sex    total\n  <chr>     <chr>  <int>\n1 Adelie    <NA>       6\n2 Adelie    female    73\n3 Adelie    male      73\n4 Chinstrap female    34\n5 Chinstrap male      34\n6 Gentoo    <NA>       5\n7 Gentoo    female    58\n8 Gentoo    male      61\n```\n\n\n:::\n:::\n\n\n\nThe same would go for multiple summary functions \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT species, COUNT(species) AS total, AVG(bill_depth_mm) AS avg_bill_depth, MEDIAN(bill_depth_mm) AS median_bill_depth\n             FROM pengs \n             GROUP BY sex\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [3 x 4]\n# Database: sqlite 3.46.0 [:memory:]\n  species total avg_bill_depth median_bill_depth\n  <chr>   <int>          <dbl>             <dbl>\n1 Adelie     11           16.6              17.1\n2 Adelie    165           16.4              17  \n3 Adelie    168           17.9              18.4\n```\n\n\n:::\n:::\n\n\n\n## Joins/Appending Rows \n\nIn the real world it is rare that we will have all our data in one place. Companies keep information in lots of different places because well it would be bad if we kept credit card information with all the necessary components to make a purchase. Instead of having to figure out three different things malicious actors would just need to access one database. Replacing entire data tables can also skyrocket costs. So instead, it is more efficient to simply insert rows. \n\n\n### Apppending Rows \n\nTo kind of mimic this we are just going to slice this data frame roughly in half. While not entirely realistic the general process will be similar enough\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\npengs_top = palmerpenguins::penguins |>\n    slice(1:172)\n\npengs_bottom = palmerpenguins::penguins |>\n    slice(173:344)\n\ncon2 = src_memdb()\n\ncon3 = src_memdb()\n\npengs_top = copy_to(con2, pengs_top)\n\npengs_bottom = copy_to(con3, pengs_bottom)\n```\n:::\n\n\n\nFor whatever reason `show_query` is not working with this so we are going to have to consult the interwebs. The `SQL` equivalent of `bind_rows` is `UNION`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con2, sql(\"SELECT * FROM pengs_top\n             UNION ALL \n             SELECT * FROM pengs_bottom\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 8]\n# Database: sqlite 3.46.0 [:memory:]\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ more rows\n# ℹ 2 more variables: sex <chr>, year <int>\n```\n\n\n:::\n:::\n\n\n\nOne of the key things in this query is `ALL` which is somewhat new to me. Basically the `ALL` tells `SQL` that we don't really care about duplicates so just add the rows regardless. So if we wanted to exclude duplicates we would do something like this \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntbl(con2, sql(\"SELECt * FROM pengs_top \n              UNION \n              SELECT * FROM pengs_top\")) |>\n                collect() |>\n                nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 172\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\ntbl(con2,sql(\"SELECT * FROM pengs_top\") ) |>\n    collect() |>\n    nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 172\n```\n\n\n:::\n:::\n\n\n\n### Joins\n\nLuckily for us the join syntax from `dplyr` is pretty directly taken `SQL` so lefts create some dummy data to join.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nnational_data <- tribble(\n  ~state, ~year, ~unemployment, ~inflation, ~population,\n  \"GA\",   2018,  5,             2,          100,\n  \"GA\",   2019,  5.3,           1.8,        200,\n  \"GA\",   2020,  5.2,           2.5,        300,\n  \"NC\",   2018,  6.1,           1.8,        350,\n  \"NC\",   2019,  5.9,           1.6,        375,\n  \"NC\",   2020,  5.3,           1.8,        400,\n  \"CO\",   2018,  4.7,           2.7,        200,\n  \"CO\",   2019,  4.4,           2.6,        300,\n  \"CO\",   2020,  5.1,           2.5,        400\n)\n\nnational_libraries <- tribble(\n  ~state, ~year, ~libraries, ~schools,\n  \"CO\",   2018,  230,        470,\n  \"CO\",   2019,  240,        440,\n  \"CO\",   2020,  270,        510,\n  \"NC\",   2018,  200,        610,\n  \"NC\",   2019,  210,        590,\n  \"NC\",   2020,  220,        530,\n)\n\ncon3 = src_memdb()\n\ncon4 = src_memdb()\n\nnational_data = copy_to(con4, national_data, overwrite = TRUE)\n\nnational_libraries = copy_to(con3, national_libraries, overwrite = TRUE)\n```\n:::\n\n\n\nSo we have some fake national level data that we would like to join in to the dataset. We could do something like this but what we notice is that it is going to decide the join keys for us and probably create some headaches for us later on. \nTo solve this we need to use our keys if we expose the underlying logic\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnational_data |>\n    left_join(national_libraries, join_by(state, year)) |>\n    show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `national_data`.*, `libraries`, `schools`\nFROM `national_data`\nLEFT JOIN `national_libraries`\n  ON (\n    `national_data`.`state` = `national_libraries`.`state` AND\n    `national_data`.`year` = `national_libraries`.`year`\n  )\n```\n\n\n:::\n:::\n\n\n\nWe will notice that `join_by` is shorthand for equality joins. What changes is that instead of `left_key = right_key` we have to specify what is coming from what table using `.`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndb_con = con4$con\n\nquery = \"SELECT *\n             FROM national_data\n             LEFT JOIN national_libraries\n             ON (\n             national_data.state = national_libraries.state AND\n             national_data.year = national_libraries.year\n             )\n             \"\n\ndbGetQuery(db_con, sql(query))       \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  state year unemployment inflation population state year libraries schools\n1    GA 2018          5.0       2.0        100  <NA>   NA        NA      NA\n2    GA 2019          5.3       1.8        200  <NA>   NA        NA      NA\n3    GA 2020          5.2       2.5        300  <NA>   NA        NA      NA\n4    NC 2018          6.1       1.8        350    NC 2018       200     610\n5    NC 2019          5.9       1.6        375    NC 2019       210     590\n6    NC 2020          5.3       1.8        400    NC 2020       220     530\n7    CO 2018          4.7       2.7        200    CO 2018       230     470\n8    CO 2019          4.4       2.6        300    CO 2019       240     440\n9    CO 2020          5.1       2.5        400    CO 2020       270     510\n```\n\n\n:::\n:::\n\n\n\n:::aside\nFor whatever reason with `SQLite` gets a little grumpy with the join syntax.\n\n:::\n\nIf we wanted to do various other joins like inner and anti joins we would do a similar thing. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquery = \"SELECT * \n        FROM national_data\n    INNER JOIN national_libraries \n    ON(\n    national_data.state = national_libraries.state AND\n    national_data.year = national_libraries.year\n    )\n\"\n\ndbGetQuery(db_con, sql(query))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  state year unemployment inflation population state year libraries schools\n1    CO 2018          4.7       2.7        200    CO 2018       230     470\n2    CO 2019          4.4       2.6        300    CO 2019       240     440\n3    CO 2020          5.1       2.5        400    CO 2020       270     510\n4    NC 2018          6.1       1.8        350    NC 2018       200     610\n5    NC 2019          5.9       1.6        375    NC 2019       210     590\n6    NC 2020          5.3       1.8        400    NC 2020       220     530\n```\n\n\n:::\n:::\n\n\n\n### Inequality joins\n\nConfession I have never really understood how inequality joins work in regular dplyr but I am sure at some point I am going to need them and now when the stakes are so low is a good time to do it. So lets just take the data from the `dplyr` 1.1.0 announcement to do this since we know what the output should be.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompanies <- tibble(\n  id = c(\"A\", \"B\", \"B\"),\n  since = c(1973, 2009, 2022),\n  name = c(\"Patagonia\", \"RStudio\", \"Posit\")\n)\n\ntransactions <- tibble(\n  company = c(\"A\", \"A\", \"B\", \"B\"),\n  year = c(2019, 2020, 2021, 2023),\n  revenue = c(50, 4, 10, 12)\n)\n\ncompanies = copy_to(con3, companies, overwrite = TRUE)\n\ntransactions = copy_to(con4, transactions, overwrite = TRUE)\n\ndb_con = con3$con\n```\n:::\n\n\n\nSo the main idea of an inequality join is that we can join by a key in this case company but only keep records from a certain date. The blog post kind of equates it with a `filter/WHERE` that happens during the join phase. So we would see something like this \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions |>\n  inner_join(companies, join_by(company == id, year >= since)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [5 x 5]\n# Database: sqlite 3.46.0 [:memory:]\n  company  year revenue since name     \n  <chr>   <dbl>   <dbl> <dbl> <chr>    \n1 A        2019      50  1973 Patagonia\n2 A        2020       4  1973 Patagonia\n3 B        2021      10  2009 RStudio  \n4 B        2023      12  2009 RStudio  \n5 B        2023      12  2022 Posit    \n```\n\n\n:::\n:::\n\n\n\nInstead of two equality statements we would effectively use the same syntax just swapping out the `=` with `>=`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquery = \"\n      SELECT * FROM transactions\n      INNER JOIN companies \n      ON(\n      transactions.company = companies.id AND\n      transactions.year >= companies.since\n      )\n\n\"\n\ndbGetQuery(db_con, sql(query))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  company year revenue id since      name\n1       A 2019      50  A  1973 Patagonia\n2       A 2020       4  A  1973 Patagonia\n3       B 2021      10  B  2009   RStudio\n4       B 2023      12  B  2009   RStudio\n5       B 2023      12  B  2022     Posit\n```\n\n\n:::\n:::\n\n\n\n\n\n# Tidyr\n\nThis section is really about pivots\n\n## Pivots \n\nIn tidyverse parlance we use pivots to change the \"shape of the data.\" If you are unfamiliar with this idea consider the religion and income data below. You will notice that we have a column for each income bracket or what is sometimes called \"wide\" data. This may be useful for some question but generally if we want to plot things or do things it will be easier if they are \"long\" data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ncon5 = src_memdb()\n\nrelig = copy_to(con5, relig_income, overwrite = TRUE)\n\nhead(relig_income, n = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 11\n  religion `<$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\n  <chr>      <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>      <dbl>\n1 Agnostic      27        34        60        81        76       137        122\n2 Atheist       12        27        37        52        35        70         73\n# ℹ 3 more variables: `$100-150k` <dbl>, `>150k` <dbl>,\n#   `Don't know/refused` <dbl>\n```\n\n\n:::\n:::\n\n\n\nTo make our data \"long\" we use `pivot_longer` and to make data \"wide\" we use `pivot_wider` each has their own quirks but the general idea is that we have to tell these functions where to put the old names/where to get the new names and where to put the old values/where to get the new values. So if we wanted to make our data longer we would do something like this.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong = relig_income |>\n    pivot_longer(-religion,\n                names_to = 'income_bracket',\n                values_to = 'income')\n\nhead(long, n = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  religion income_bracket income\n  <chr>    <chr>           <dbl>\n1 Agnostic <$10k              27\n2 Agnostic $10-20k            34\n```\n\n\n:::\n:::\n\n\n\nIf we wanted to make this wide again all we would do is reverse this with `pivot_wider`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwide = long |>\n    pivot_wider(names_from = income_bracket, values_from = income)\n```\n:::\n\n\n\n:::aside\nThere are ton of additional functionality that will not be covered like dealing with not uniquely identified columns.\n\n:::\n\nTo get a sense of how to do this let’s consult our old friend `show_query` \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrelig |>\n    pivot_longer(-religion,\n                names_to = 'income_bracket',\n                values_to = 'income') |>\n                    show_query()\n```\n:::\n\n\n\nWe are not going to actually show the results because it is quite the query. The summary of what is happening is that `SQLite` doesn't have a perfect equivalent of `pivot_longer`. Basically, what you need to do is to keep appending smaller and smaller data frames to each other until you get to a long data frame. In other flavors of SQL this process is a lot more humane with explicit `PIVOT` and `UNPIVOT` but I am not in one of those flavors. To spare myself a bit I am just going to do two columns\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con5, sql(\"\n    SELECT religion, '<$10k' AS income_bracket, '<$10k' AS income\n    FROM relig_income \n\n    UNION ALL\n\n    SELECT religion, '$10-20k' AS income_bracket, '$10-20k' AS income\n    FROM relig_income\n\n    UNION ALL\n\n    SELECT religion, '$20-30k' AS income_bracket, '$20-30k' AS income\n    FROM relig_income\n\n    \n\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 3]\n# Database: sqlite 3.46.0 [:memory:]\n   religion                income_bracket income\n   <chr>                   <chr>          <chr> \n 1 Agnostic                <$10k          <$10k \n 2 Atheist                 <$10k          <$10k \n 3 Buddhist                <$10k          <$10k \n 4 Catholic                <$10k          <$10k \n 5 Don’t know/refused      <$10k          <$10k \n 6 Evangelical Prot        <$10k          <$10k \n 7 Hindu                   <$10k          <$10k \n 8 Historically Black Prot <$10k          <$10k \n 9 Jehovah's Witness       <$10k          <$10k \n10 Jewish                  <$10k          <$10k \n# ℹ more rows\n```\n\n\n:::\n:::\n\n\n\nI am a little scared to see what this looks for `pivot_wider` but we should at least give it a go. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong = relig |>\n    pivot_longer(-religion,\n                 names_to = 'income_bracket',\n                 values_to = 'income')\n\nlong |>\n    pivot_wider(names_from = income_bracket, values_from = income) |>\n    show_query()\n```\n:::\n\n\n\nOkay again this is a little unwieldy to show. Basically what happens is that we are creating a big case_when condition and then from there we are going to use the same binding trick and then group the data. So lets go ahead and copy and paste some of this.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nquery = \"\nSELECT\n    religion,\n    MAX(CASE WHEN (income_bracket = '<$10k') THEN income END) AS '<$10K',\n    MAX(CASE WHEN (income_bracket = '$10-20k') THEN income END) AS '$10-20k',\n    MAX(CASE WHEN (income_bracket = '$20-30k') THEN income END) AS '$20-30k'\nFROM (\n    SELECT religion, '<$10k' AS income_bracket, '<$10k' AS income\n    FROM relig_income\n\n    UNION ALL\n\n    SELECT religion, '$10-20k' AS income_bracket, '$10-20k' AS income\n    FROM relig_income\n\n    UNION ALL\n\n    SELECT religion, '$20-30k' AS income_bracket, '$20-30k' AS income\n    FROM relig_income\n) AS wide_religion\nGROUP BY religion\n\"\n\ntbl(con5, sql(query))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 4]\n# Database: sqlite 3.46.0 [:memory:]\n   religion                `<$10K` `$10-20k` `$20-30k`\n   <chr>                   <chr>   <chr>     <chr>    \n 1 Agnostic                <$10k   $10-20k   $20-30k  \n 2 Atheist                 <$10k   $10-20k   $20-30k  \n 3 Buddhist                <$10k   $10-20k   $20-30k  \n 4 Catholic                <$10k   $10-20k   $20-30k  \n 5 Don’t know/refused      <$10k   $10-20k   $20-30k  \n 6 Evangelical Prot        <$10k   $10-20k   $20-30k  \n 7 Hindu                   <$10k   $10-20k   $20-30k  \n 8 Historically Black Prot <$10k   $10-20k   $20-30k  \n 9 Jehovah's Witness       <$10k   $10-20k   $20-30k  \n10 Jewish                  <$10k   $10-20k   $20-30k  \n# ℹ more rows\n```\n\n\n:::\n:::\n\n\n\n## Unnest/a brief aside\n\nSo one thing that you come across from time to time in R and python data wrangling are list columns. These happen for a variety of reasons and are pretty innocuous to handle.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_starwars = starwars |>\n    select(name, films)\n\n list_starwars |>\n    unnest_longer(films)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 173 × 2\n   name           films                  \n   <chr>          <chr>                  \n 1 Luke Skywalker A New Hope             \n 2 Luke Skywalker The Empire Strikes Back\n 3 Luke Skywalker Return of the Jedi     \n 4 Luke Skywalker Revenge of the Sith    \n 5 Luke Skywalker The Force Awakens      \n 6 C-3PO          A New Hope             \n 7 C-3PO          The Empire Strikes Back\n 8 C-3PO          Return of the Jedi     \n 9 C-3PO          The Phantom Menace     \n10 C-3PO          Attack of the Clones   \n# ℹ 163 more rows\n```\n\n\n:::\n:::\n\n\n\nHowever, per [this Stack overflow answer](https://stackoverflow.com/questions/3070384/how-to-store-a-list-in-a-column-of-a-database-table) and the linked question this is not really a thing or like really not advised. Even when you try to copy the starwars dataset to a database you get an error.\n\n\n\n## Misc\n\n## Ranking \n\nThere are lots of different ways to rank things in R if we want to return the min/max you can do \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npengs |>\n    slice_max(bill_length_mm, n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [3 x 8]\n# Database: sqlite 3.46.0 [:memory:]\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <chr>     <chr>           <dbl>         <dbl>             <int>       <int>\n1 Gentoo    Biscoe           59.6          17                 230        6050\n2 Chinstrap Dream            58            17.8               181        3700\n3 Gentoo    Biscoe           55.9          17                 228        5600\n# ℹ 2 more variables: sex <chr>, year <int>\n```\n\n\n:::\n:::\n\n\n\nThere are also various ranking functions.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample = tribble(~id, ~col1,\n                   1, 1,\n                   2, 2,\n                   3, 2,\n                   4, 3,\n                   5, 4)\n\nexample |>\n    mutate(rank_one = dense_rank(col1),\n           rank_two = min_rank(col1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n     id  col1 rank_one rank_two\n  <dbl> <dbl>    <int>    <int>\n1     1     1        1        1\n2     2     2        2        2\n3     3     2        2        2\n4     4     3        3        4\n5     5     4        4        5\n```\n\n\n:::\n:::\n\n\n\nLike our `dplyr` join functions the `dense_rank` and `min_rank` function actually takes inspiration from `SQL`. So in our example where the two functions differ is how they handle ties. So in `dense_rank` and `min_rank` both id 2 and 3 get assigned the same rank where they differ is `dense_rank` will assign id 4 the rank of 3 and `min_rank` will assign id 4 the rank of 4. \n\nSo how would we do this in `SQL`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon7 = src_memdb()\n\nteam_rankings = copy_to(con7, example)\n\nteam_rankings |>\n    mutate(rank_one = dense_rank(col1)) |>\n    show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT\n  `example`.*,\n  CASE\nWHEN (NOT((`col1` IS NULL))) THEN DENSE_RANK() OVER (PARTITION BY (CASE WHEN ((`col1` IS NULL)) THEN 1 ELSE 0 END) ORDER BY `col1`)\nEND AS `rank_one`\nFROM `example`\n```\n\n\n:::\n:::\n\n\n\nThis is deceptively a bit more complex. So lets break it down.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con7, sql(\"\nSELECT\nexample .*,\n    CASE \nWHEN (NOT((col1 is NULL))) THEN DENSE_RANK() OVER (PARTITION BY (CASE WHEN ((col1 is NULL)) THEN 1 ELSE 0 END) ORDER BY col1)\nEND AS rank_one\nFROM example\n\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [5 x 3]\n# Database: sqlite 3.46.0 [:memory:]\n     id  col1 rank_one\n  <dbl> <dbl>    <int>\n1     1     1        1\n2     2     2        2\n3     3     2        2\n4     4     3        3\n5     5     4        4\n```\n\n\n:::\n:::\n\n\n\nSo basically the `PARTITION BY` bit is used to divide the data into groups before we rank them. The `CASE WHEN` handles when we have missing values. Then the window function is applying dense rank over these partions. This was a somewhat silly example so lets do something a bit more realistic. Lets say we actually want to rank the penguins by average bill length and then return the penguins in the top 3. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\n    \"\n    SELECT\n    ranked_pengs .*,\n    CASE\n    WHEN (NOT((avg_bill_length is NULL))) THEN DENSE_RANK() OVER (PARTITION BY (CASE WHEN ((avg_bill_length is NULL)) THEN 1 ELSE 0 END) ORDER BY avg_bill_length)\n    END AS rank\n    FROM( \n     SELECT pengs .*, AVG(bill_length_mm) OVER () AS avg_bill_length\n     FROM pengs)\n     AS ranked_pengs \n     LIMIT 3\n    \"\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [3 x 10]\n# Database: sqlite 3.46.0 [:memory:]\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <chr>   <chr>              <dbl>         <dbl>             <int>       <int>\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n# ℹ 4 more variables: sex <chr>, year <int>, avg_bill_length <dbl>, rank <int>\n```\n\n\n:::\n:::\n\n\n\nWe could also do this by groups by just inserting a group by statement before the limit bit\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\n    \"\n    SELECT\n    ranked_pengs .*,\n    CASE\n    WHEN (NOT((avg_bill_length is NULL))) THEN DENSE_RANK() OVER (PARTITION BY (CASE WHEN ((avg_bill_length is NULL)) THEN 1 ELSE 0 END) ORDER BY avg_bill_length)\n    END AS rank\n    FROM( \n     SELECT pengs .*, AVG(bill_length_mm) OVER () AS avg_bill_length\n     FROM pengs)\n     AS ranked_pengs \n     GROUP BY species\n     LIMIT 3\n    \"\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [3 x 10]\n# Database: sqlite 3.46.0 [:memory:]\n  species   island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <chr>     <chr>              <dbl>         <dbl>             <int>       <int>\n1 Adelie    Torgersen           39.1          18.7               181        3750\n2 Chinstrap Dream               46.5          17.9               192        3500\n3 Gentoo    Biscoe              46.1          13.2               211        4500\n# ℹ 4 more variables: sex <chr>, year <int>, avg_bill_length <dbl>, rank <int>\n```\n\n\n:::\n:::\n\n\n\n## Distinct Values\n \nDuplicates are a fact of life but depending on your question or what information you are trying to show repeated records may not be desirable. We handle these with the same function but kind of like `mutate` we have to let select handle these. If we wanted one row per column without having to specify every column in our dataset than we could do something like this\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT *\n            FROM(\n            SELECT pengs .*,\n            ROW_NUMBER() OVER (PARTITION BY species ORDER BY species) AS id \n            FROM PENGS) AS small_pengs\n            WHERE id = 1\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [3 x 9]\n# Database: sqlite 3.46.0 [:memory:]\n  species   island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <chr>     <chr>              <dbl>         <dbl>             <int>       <int>\n1 Adelie    Torgersen           39.1          18.7               181        3750\n2 Chinstrap Dream               46.5          17.9               192        3500\n3 Gentoo    Biscoe              46.1          13.2               211        4500\n# ℹ 3 more variables: sex <chr>, year <int>, id <int>\n```\n\n\n:::\n:::\n\n\n\n\nHowever if we have a slightly less complex query than we can feed distinct multiple columns\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, sql(\"SELECT DISTINCT species, island\n            FROM pengs\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [5 x 2]\n# Database: sqlite 3.46.0 [:memory:]\n  species   island   \n  <chr>     <chr>    \n1 Adelie    Torgersen\n2 Adelie    Biscoe   \n3 Adelie    Dream    \n4 Gentoo    Biscoe   \n5 Chinstrap Dream    \n```\n\n\n:::\n:::\n\n\n\n\n## The End...for now \n\nI am sure this will end up growing as I think of more than things in R that I need to be able to do in SQL. \n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}